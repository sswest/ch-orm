<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>querysets</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="querysets">Querysets</h1>
<p>A queryset is an object that represents a database query using a
specific Model. It is lazy, meaning that it does not hit the database
until you iterate over its matching rows (model instances). To create a
base queryset for a model class, use:</p>
<pre><code>qs = Person.objects_in(database)</code></pre>
<p>This queryset matches all Person instances in the database. You can
get these instances using iteration:</p>
<pre><code>for person in qs:
    print(person.first_name, person.last_name)</code></pre>
<p>For AioDatabase instances:</p>
<pre><code>async for person in qs:
    print(person.first_name, person.last_name)</code></pre>
<h2 id="filtering">Filtering</h2>
<p>The <code>filter</code> and <code>exclude</code> methods are used for
filtering the matching instances. Calling these methods returns a new
queryset instance, with the added conditions. For example:</p>
<pre><code>&gt;&gt;&gt; qs = Person.objects_in(database)
&gt;&gt;&gt; qs = qs.filter(F.like(Person.first_name, &#39;V%&#39;)).exclude(Person.birthday &lt; &#39;2000-01-01&#39;)
&gt;&gt;&gt; qs.conditions_as_sql()
&quot;first_name LIKE &#39;V%&#39; AND NOT (birthday &lt; &#39;2000-01-01&#39;)&quot;</code></pre>
<p>It is possible to specify several expressions to filter or exclude
by, and they will be ANDed together:</p>
<pre><code>&gt;&gt;&gt; qs = Person.objects_in(database).filter(Person.last_name == &#39;Smith&#39;, Person.height &gt; 1.75)
&gt;&gt;&gt; qs.conditions_as_sql()
&quot;last_name = &#39;Smith&#39; AND height &gt; 1.75&quot;</code></pre>
<p>For compound conditions you can use the overloaded operators
<code>&amp;</code> (AND), <code>|</code> (OR) and <code>~</code>
(NOT):</p>
<pre><code>&gt;&gt;&gt; qs = Person.objects_in(database)
&gt;&gt;&gt; qs = qs.filter(((Person.first_name == &#39;Ciaran&#39;) &amp; (Person.last_name == &#39;Carver&#39;)) | (Person.height &lt;= 1.8) &amp; ~(Person.first_name = &#39;David&#39;))
&gt;&gt;&gt; qs.conditions_as_sql()
&quot;((first_name = &#39;Ciaran&#39; AND last_name = &#39;Carver&#39;) OR height &lt;= 1.8) AND (NOT (first_name = &#39;David&#39;))&quot;</code></pre>
<p>Note that Python’s bitwise operators (<code>&amp;</code>,
<code>|</code>, <code>~</code>, <code>^</code>) have higher precedence
than comparison operators, so always use parentheses when combining
these two types of operators in an expression. Otherwise the resulting
SQL might be different than what you would expect.</p>
<h3 id="using-in-and-not-in">Using <code>IN</code> and
<code>NOT IN</code></h3>
<p>Filtering queries using ClickHouse’s <code>IN</code> and
<code>NOT IN</code> operators requires using the <code>isIn</code> and
<code>isNotIn</code> functions (trying to use Python’s <code>in</code>
keyword will not work!). For example:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Is it Monday, Tuesday or Wednesday?</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>F.isIn(F.toDayOfWeek(F.now()), [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co"># This will not work:</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>F.toDayOfWeek(F.now()) <span class="kw">in</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span></code></pre></div>
<p>In case of model fields, there is a simplified syntax:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Filtering using F.isIn:</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>qs.<span class="bu">filter</span>(F.isIn(Person.first_name, [<span class="st">&#39;Robert&#39;</span>, <span class="st">&#39;Rob&#39;</span>, <span class="st">&#39;Robbie&#39;</span>]))</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Simpler syntax using isIn directly on the field:</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>qs.<span class="bu">filter</span>(Person.first_name.isIn([<span class="st">&#39;Robert&#39;</span>, <span class="st">&#39;Rob&#39;</span>, <span class="st">&#39;Robbie&#39;</span>]))</span></code></pre></div>
<p>The <code>isIn</code> and <code>isNotIn</code> functions expect
either a list/tuple of values, or another queryset (a subquery). For
example if we want to select only people with Irish last names:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Last name is in a list of values</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>qs <span class="op">=</span> Person.objects_in(database).<span class="bu">filter</span>(Person.last_name.isIn([<span class="st">&quot;Murphy&quot;</span>, <span class="st">&quot;O&#39;Sullivan&quot;</span>]))</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Last name is in a subquery</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>subquery <span class="op">=</span> IrishLastName.objects_in(database).only(<span class="st">&quot;name&quot;</span>)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>qs <span class="op">=</span> Person.objects_in(database).<span class="bu">filter</span>(Person.last_name.isIn(subquery))</span></code></pre></div>
<h3 id="specifying-prewhere-conditions">Specifying PREWHERE
conditions</h3>
<p>By default conditions from <code>filter</code> and
<code>exclude</code> methods are add to <code>WHERE</code> clause. For
better aggregation performance you can add them to <code>PREWHERE</code>
section by adding a <code>prewhere=True</code> parameter:</p>
<pre><code>&gt;&gt;&gt; qs = Person.objects_in(database)
&gt;&gt;&gt; qs = qs.filter(F.like(Person.first_name, &#39;V%&#39;), prewhere=True)
&gt;&gt;&gt; qs.conditions_as_sql(prewhere=True)
&quot;first_name LIKE &#39;V%&#39;&quot;</code></pre>
<h3 id="old-style-filter-conditions">Old-style filter conditions</h3>
<p>Prior to version 2 of the ORM, filtering conditions were limited to a
predefined set of operators, and complex expressions were not supported.
This old syntax is still available, so you can use it alongside or even
intermixed with new-style functions and expressions.</p>
<p>The old syntax uses keyword arguments to the <code>filter</code> and
<code>exclude</code> methods, that are built as
<code>&lt;fieldname&gt;__&lt;operator&gt;=&lt;value&gt;</code> (two
underscores separate the field name from the operator). In case no
operator is given, <code>eq</code> is used by default. For example:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>qs <span class="op">=</span> Position.objects.<span class="kw">in</span>(database)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co"># New style</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>qs <span class="op">=</span> qs.<span class="bu">filter</span>(Position.x <span class="op">&gt;</span> <span class="dv">100</span>, Position.y <span class="op">&lt;</span> <span class="dv">20</span>, Position.terrain <span class="op">==</span> <span class="st">&#39;water&#39;</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Old style</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>qs <span class="op">=</span> qs.<span class="bu">filter</span>(x__gt<span class="op">=</span><span class="dv">100</span>, y__lt<span class="op">=</span><span class="dv">20</span>, terrain<span class="op">=</span><span class="st">&#39;water&#39;</span>)</span></code></pre></div>
<p>Below are all the supported operators.</p>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 48%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr class="header">
<th>Operator</th>
<th>Equivalent SQL</th>
<th>Comments</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>eq</code></td>
<td><code>field = value</code></td>
<td></td>
</tr>
<tr class="even">
<td><code>ne</code></td>
<td><code>field != value</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code>gt</code></td>
<td><code>field &gt; value</code></td>
<td></td>
</tr>
<tr class="even">
<td><code>gte</code></td>
<td><code>field &gt;= value</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code>lt</code></td>
<td><code>field &lt; value</code></td>
<td></td>
</tr>
<tr class="even">
<td><code>lte</code></td>
<td><code>field &lt;= value</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code>between</code></td>
<td><code>field BETWEEN value1 AND value2</code></td>
<td></td>
</tr>
<tr class="even">
<td><code>in</code></td>
<td><code>field IN (values)</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code>gin</code></td>
<td><code>field GLOBAL IN (values)</code></td>
<td></td>
</tr>
<tr class="even">
<td><code>not_in</code></td>
<td><code>field NOT IN (values)</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code>not_gin</code></td>
<td><code>field NOT GLOBAL IN (values)</code></td>
<td></td>
</tr>
<tr class="even">
<td><code>contains</code></td>
<td><code>field LIKE '%value%'</code></td>
<td>For string fields only</td>
</tr>
<tr class="odd">
<td><code>startswith</code></td>
<td><code>field LIKE 'value%'</code></td>
<td>For string fields only</td>
</tr>
<tr class="even">
<td><code>endswith</code></td>
<td><code>field LIKE '%value'</code></td>
<td>For string fields only</td>
</tr>
<tr class="odd">
<td><code>icontains</code></td>
<td><code>lowerUTF8(field) LIKE lowerUTF8('%value%')</code></td>
<td>For string fields only</td>
</tr>
<tr class="even">
<td><code>istartswith</code></td>
<td><code>lowerUTF8(field) LIKE lowerUTF8('value%')</code></td>
<td>For string fields only</td>
</tr>
<tr class="odd">
<td><code>iendswith</code></td>
<td><code>lowerUTF8(field) LIKE lowerUTF8('%value')</code></td>
<td>For string fields only</td>
</tr>
<tr class="even">
<td><code>iexact</code></td>
<td><code>lowerUTF8(field) = lowerUTF8(value)</code></td>
<td>For string fields only</td>
</tr>
</tbody>
</table>
<h2 id="counting-and-checking-existence">Counting and Checking
Existence</h2>
<p>Use the <code>count</code> method to get the number of matches:</p>
<pre><code>Person.objects_in(database).count()

# aio
# await Person.objects_in(database).count()</code></pre>
<p>To check if there are any matches at all, you can use any of the
following equivalent options:</p>
<pre><code>if qs.count(): ...
if bool(qs): ...
if qs: ...</code></pre>
<h2 id="ordering">Ordering</h2>
<p>The sorting order of the results can be controlled using the
<code>order_by</code> method:</p>
<pre><code>qs = Person.objects_in(database).order_by(&#39;last_name&#39;, &#39;first_name&#39;)</code></pre>
<p>The default order is ascending. To use descending order, add a minus
sign before the field name:</p>
<pre><code>qs = Person.objects_in(database).order_by(&#39;-height&#39;)</code></pre>
<p>If you do not use <code>order_by</code>, the rows are returned in
arbitrary order.</p>
<h2 id="omitting-fields">Omitting Fields</h2>
<p>When some of the model fields aren’t needed, it is more efficient to
omit them from the query. This is especially true when there are large
fields that may slow the query down. Use the <code>only</code> method to
specify which fields to retrieve:</p>
<pre><code>qs = Person.objects_in(database).only(&#39;first_name&#39;, &#39;birthday&#39;)</code></pre>
<h2 id="distinct">Distinct</h2>
<p>Adds a DISTINCT clause to the query, meaning that any duplicate rows
in the results will be omitted.</p>
<pre><code>&gt;&gt;&gt; Person.objects_in(database).only(&#39;first_name&#39;).count()
100
&gt;&gt;&gt; Person.objects_in(database).only(&#39;first_name&#39;).distinct().count()
94</code></pre>
<h2 id="final">Final</h2>
<p>This method can be used only with <code>CollapsingMergeTree</code>
engine. Adds a FINAL modifier to the query, meaning that the selected
data is fully “collapsed” by the engine’s sign field.</p>
<pre><code>&gt;&gt;&gt; Person.objects_in(database).count()
100
&gt;&gt;&gt; Person.objects_in(database).final().count()
94</code></pre>
<h2 id="slicing">Slicing</h2>
<p>It is possible to get a specific item from the queryset by index
(<strong>not applicable to AioDatabase)</strong>:</p>
<pre><code>  qs = Person.objects_in(database).order_by(&#39;last_name&#39;, &#39;first_name&#39;)
  first = qs[0]</code></pre>
<p>It is also possible to get a range a instances using a slice. This
returns a queryset, that you can either iterate over or convert to a
list.</p>
<pre><code>  qs = Person.objects_in(database).order_by(&#39;last_name&#39;, &#39;first_name&#39;)
  first_ten_people = list(qs[:10])
  next_ten_people  = list(qs[10:20])

  # first_ten_people = [_ async for _ in qs[:10]]
  # next_ten_people  = [_ async for _ in qs[10:20]]</code></pre>
<p>You should use <code>order_by</code> to ensure a consistent ordering
of the results.</p>
<p>Trying to use negative indexes or a slice with a step (e.g. [0 : 100
: 2]) is not supported and will raise an
<code>AssertionError</code>.</p>
<h2 id="pagination">Pagination</h2>
<p>Similar to <code>Database.paginate</code>, you can go over the
queryset results one page at a time:</p>
<pre><code>&gt;&gt;&gt; qs = Person.objects_in(database).order_by(&#39;last_name&#39;, &#39;first_name&#39;)
&gt;&gt;&gt; page = qs.paginate(page_num=1, page_size=10)
&gt;&gt;&gt; print(page.number_of_objects)
2507
&gt;&gt;&gt; print(page.pages_total)
251
&gt;&gt;&gt; for person in page.objects:
&gt;&gt;&gt;     # do something</code></pre>
<p>The <code>paginate</code> method returns a <code>namedtuple</code>
containing the following fields:</p>
<ul>
<li><code>objects</code> - the list of objects in this page</li>
<li><code>number_of_objects</code> - total number of objects in all
pages</li>
<li><code>pages_total</code> - total number of pages</li>
<li><code>number</code> - the page number, starting from 1; the special
value -1 may be used to retrieve the last page</li>
<li><code>page_size</code> - the number of objects per page</li>
</ul>
<p>Note that you should use <code>QuerySet.order_by</code> so that the
ordering is unique, otherwise there might be inconsistencies in the
pagination (such as an instance that appears on two different
pages).</p>
<h2 id="mutations">Mutations</h2>
<p>To delete all records that match a queryset’s conditions use the
<code>delete</code> method:</p>
<pre><code>Person.objects_in(database).filter(first_name=&#39;Max&#39;).delete()</code></pre>
<p>To update records that match a queryset’s conditions call the
<code>update</code> method and provide the field names to update and the
expressions to use (as keyword arguments):</p>
<pre><code>Person.objects_in(database).filter(first_name=&#39;Max&#39;).update(first_name=&#39;Maximilian&#39;)</code></pre>
<p>Note a few caveats:</p>
<ul>
<li>ClickHouse cannot update columns that are used in the calculation of
the primary or the partition key.</li>
<li>Mutations happen in the background, so they are not immediate.</li>
<li>Only tables in the <code>MergeTree</code> family support
mutations.</li>
</ul>
<h2 id="aggregation">Aggregation</h2>
<p>It is possible to use aggregation functions over querysets using the
<code>aggregate</code> method. The simplest form of aggregation works
over all rows in the queryset:</p>
<pre><code>&gt;&gt;&gt; qs = Person.objects_in(database).aggregate(average_height=F.avg(Person.height))
&gt;&gt;&gt; print(qs.count())
1
&gt;&gt;&gt; for row in qs: print(row.average_height)
1.71</code></pre>
<p>The returned row or rows are no longer instances of the base model
(<code>Person</code> in this example), but rather instances of an ad-hoc
model that includes only the fields specified in the call to
<code>aggregate</code>.</p>
<p>You can pass fields from the model that will be included in the
query. By default, they will be also used in the GROUP BY clause. For
example to count the number of people per last name you could do
this:</p>
<pre><code>qs = Person.objects_in(database).aggregate(Person.last_name, num=F.count())</code></pre>
<p>The underlying SQL query would be something like this:</p>
<pre><code>SELECT last_name, count() AS num
FROM person
GROUP BY last_name</code></pre>
<p>If you would like to control the GROUP BY explicitly, use the
<code>group_by</code> method. This is useful when you need to group by a
calculated field, instead of a field that exists in the model. For
example, to count the number of people born on each weekday:</p>
<pre><code>qs = Person.objects_in(database).aggregate(weekday=F.toDayOfWeek(Person.birthday), num=F.count()).group_by(&#39;weekday&#39;)</code></pre>
<p>This queryset is translated to:</p>
<pre><code>SELECT toDayOfWeek(birthday) AS weekday, count() AS num
FROM person
GROUP BY weekday</code></pre>
<p>After calling <code>aggregate</code> you can still use most of the
regular queryset methods, such as <code>count</code>,
<code>order_by</code> and <code>paginate</code>. It is not possible,
however, to call <code>only</code> or <code>aggregate</code>. It is also
not possible to filter the aggregated queryset on calculated fields,
only on fields that exist in the model.</p>
<h3 id="adding-totals">Adding totals</h3>
<p>If you limit aggregation results, it might be useful to get total
aggregation values for all rows. To achieve this, you can use
<code>with_totals</code> method. It will return extra row (last) with
values aggregated for all rows suitable for filters.</p>
<pre><code>qs = Person.objects_in(database).aggregate(Person.first_name, num=F.count()).with_totals().order_by(&#39;-count&#39;)[:3]
&gt;&gt;&gt; print(qs.count())
4
&gt;&gt;&gt; for row in qs:
&gt;&gt;&gt;     print(&quot;&#39;{}&#39;: {}&quot;.format(row.first_name, row.count))
&#39;Cassandra&#39;: 2
&#39;Alexandra&#39;: 2
&#39;&#39;: 100</code></pre>
<hr />
<p><a href="importing_orm_classes.md">&lt;&lt; Importing ORM Classes</a>
| <a href="toc.md">Table of Contents</a> | <a
href="field_options.md">Field Options &gt;&gt;</a></p>
</body>
</html>
